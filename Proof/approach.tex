\section{Approach}
\begin{normalsize}
My approach to exercises 1-5 largely combined pattern matching and guards, reusing functions where I could. Most of my functions involved a recursive definition for the main function, and usually some form of auxiliary function.  In order to test my functions, I wrote a variety of ‘test’ inputs and outputs, and tested their results by hand as well as comparing with my peers. This proved to be inefficient, but helped iron out small issues. For some, such as free variables, I wrote a small java program to generate random integers between 1 and 4, relating to each element of the \texttt{Expr} Data type, then substituted in Strings for each element. With a few tweaks, and the addition of lambda integer values by hand, this proved a reasonably effective way of generating a variety of inputs quickly, as I found writing them out by hand to be time consuming.  I’ve included an example of some of my tests for each exercise in appendix 1. The disadvantage of this method was that while a range of inputs were generated, edge cases were rarely tested. \\
An additional method I used for testing was splitting elements of my function into subfunctions, then testing these with individual use cases using GHCi. This again proved to be inefficient, but was essential in diagnosing small bugs with my code that were causing problems inside larger combinations of functions. This was particularly useful for the translate function as well as exercise substitute, in which my implementation required a lot of sub-functions. Testing allvars and nextint on individual inputs was invaluable. \\
When approaching the pretty printer, I began with the problem by attempting to generalize my function as much as possible, and attempted to avoid hard coding combinations of expressions in order to satisfy bracketing requirements.  \\
With regard to Exercise 4, I initially drew a flow chart of the processes the values would have to go through. I initially failed to include \texttt{HLam}, which allows for later conversion of Lam $->$ K/S types, but realised this issue reasonably quickly. This served me well, as I was able to identify the three key stages (represented in my code as \texttt{toH}, \texttt{ft}, and \texttt{out}). I was disappointed that I needed to implement another freeVariables method, but I felt it was easier than parsing output from my existing implementation. 
\end{normalsize}

